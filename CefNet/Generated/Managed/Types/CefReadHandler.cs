// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_read_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	///  Structure the client can implement to provide a custom stream reader. The
	///  functions of this structure may be called on any thread.
	/// </summary>
	/// <remarks>
	///  Role: Handler
	/// </remarks>
	public unsafe class CefReadHandler : CefBaseRefCounted<cef_read_handler_t>, ICefReadHandlerPrivate
	{
		private static readonly ReadDelegate fnRead = ReadImpl;

		private static readonly SeekDelegate fnSeek = SeekImpl;

		private static readonly TellDelegate fnTell = TellImpl;

		private static readonly EofDelegate fnEof = EofImpl;

		private static readonly MayBlockDelegate fnMayBlock = MayBlockImpl;

		public CefReadHandler()
		{
			var self = NativeInstance;
			self->read = (void*) Marshal.GetFunctionPointerForDelegate(fnRead);
			self->seek = (void*) Marshal.GetFunctionPointerForDelegate(fnSeek);
			self->tell = (void*) Marshal.GetFunctionPointerForDelegate(fnTell);
			self->eof = (void*) Marshal.GetFunctionPointerForDelegate(fnEof);
			self->may_block = (void*) Marshal.GetFunctionPointerForDelegate(fnMayBlock);
		}

		public CefReadHandler(cef_read_handler_t* instance)
			: base((cef_base_ref_counted_t*) instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefReadHandlerPrivate.AvoidRead();

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefReadHandlerPrivate.AvoidSeek();

		internal static CefReadHandler Create(IntPtr instance)
		{
			return new CefReadHandler((cef_read_handler_t*) instance);
		}

		/// <summary>
		///  Read raw binary data.
		/// </summary>
		protected internal virtual long Read(IntPtr ptr, long size, long n)
		{
			return default;
		}

		// size_t (*)(_cef_read_handler_t* self, void* ptr, size_t size, size_t n)*
		private static UIntPtr ReadImpl(cef_read_handler_t* self, void* ptr, UIntPtr size, UIntPtr n)
		{
			var instance = GetInstance((IntPtr) self) as CefReadHandler;
			if (instance == null || ((ICefReadHandlerPrivate) instance).AvoidRead()) return default;
			return new UIntPtr((ulong) instance.Read((IntPtr) ptr, (long) size, (long) n));
		}

		/// <summary>
		///  Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
		///  SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
		/// </summary>
		protected internal virtual int Seek(long offset, int whence)
		{
			return default;
		}

		// int (*)(_cef_read_handler_t* self, int64 offset, int whence)*
		private static int SeekImpl(cef_read_handler_t* self, long offset, int whence)
		{
			var instance = GetInstance((IntPtr) self) as CefReadHandler;
			if (instance == null || ((ICefReadHandlerPrivate) instance).AvoidSeek()) return default;
			return instance.Seek(offset, whence);
		}

		/// <summary>
		///  Return the current offset position.
		/// </summary>
		protected internal virtual long Tell()
		{
			return default;
		}

		// int64 (*)(_cef_read_handler_t* self)*
		private static long TellImpl(cef_read_handler_t* self)
		{
			var instance = GetInstance((IntPtr) self) as CefReadHandler;
			if (instance == null) return default;
			return instance.Tell();
		}

		/// <summary>
		///  Return non-zero if at end of file.
		/// </summary>
		protected internal virtual int Eof()
		{
			return default;
		}

		// int (*)(_cef_read_handler_t* self)*
		private static int EofImpl(cef_read_handler_t* self)
		{
			var instance = GetInstance((IntPtr) self) as CefReadHandler;
			if (instance == null) return default;
			return instance.Eof();
		}

		/// <summary>
		///  Return true (1) if this handler performs work like accessing the file
		///  system which may block. Used as a hint for determining the thread to access
		///  the handler from.
		/// </summary>
		protected internal virtual bool MayBlock()
		{
			return default;
		}

		// int (*)(_cef_read_handler_t* self)*
		private static int MayBlockImpl(cef_read_handler_t* self)
		{
			var instance = GetInstance((IntPtr) self) as CefReadHandler;
			if (instance == null) return default;
			return instance.MayBlock() ? 1 : 0;
		}

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate UIntPtr ReadDelegate(cef_read_handler_t* self, void* ptr, UIntPtr size, UIntPtr n);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate int SeekDelegate(cef_read_handler_t* self, long offset, int whence);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate long TellDelegate(cef_read_handler_t* self);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate int EofDelegate(cef_read_handler_t* self);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate int MayBlockDelegate(cef_read_handler_t* self);
	}
}