// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_v8value_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using CefNet.CApi;

namespace CefNet
{
	/// <summary>
	///  Structure representing a V8 value handle. V8 handles can only be accessed
	///  from the thread on which they are created. Valid threads for creating a V8
	///  handle include the render process main thread (TID_RENDERER) and WebWorker
	///  threads. A task runner for posting tasks on the associated thread can be
	///  retrieved via the cef_v8context_t::get_task_runner() function.
	/// </summary>
	/// <remarks>
	///  Role: Proxy
	/// </remarks>
	public unsafe partial class CefV8Value : CefBaseRefCounted<cef_v8value_t>
	{
		public CefV8Value(cef_v8value_t* instance)
			: base((cef_base_ref_counted_t*) instance)
		{
		}

		/// <summary>
		///  Gets a value indicating whether the underlying handle is valid and it can be accessed
		///  on the current thread. Do not call any other functions if this property
		///  returns false.
		/// </summary>
		public virtual bool IsValid => SafeCall(NativeInstance->IsValid() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is undefined.
		/// </summary>
		public virtual bool IsUndefined => SafeCall(NativeInstance->IsUndefined() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is null.
		/// </summary>
		public virtual bool IsNull => SafeCall(NativeInstance->IsNull() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is bool.
		/// </summary>
		public virtual bool IsBool => SafeCall(NativeInstance->IsBool() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is int.
		/// </summary>
		public virtual bool IsInt => SafeCall(NativeInstance->IsInt() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is unsigned int.
		/// </summary>
		public virtual bool IsUInt => SafeCall(NativeInstance->IsUInt() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is double.
		/// </summary>
		public virtual bool IsDouble => SafeCall(NativeInstance->IsDouble() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is Date.
		/// </summary>
		public virtual bool IsDate => SafeCall(NativeInstance->IsDate() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is string.
		/// </summary>
		public virtual bool IsString => SafeCall(NativeInstance->IsString() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is object.
		/// </summary>
		public virtual bool IsObject => SafeCall(NativeInstance->IsObject() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is array.
		/// </summary>
		public virtual bool IsArray => SafeCall(NativeInstance->IsArray() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is an ArrayBuffer.
		/// </summary>
		public virtual bool IsArrayBuffer => SafeCall(NativeInstance->IsArrayBuffer() != 0);

		/// <summary>
		///  Gets a value indicating whether the value type is function.
		/// </summary>
		public virtual bool IsFunction => SafeCall(NativeInstance->IsFunction() != 0);

		/// <summary>
		///  Gets a value indicating whether this is a user created object.
		/// </summary>
		public virtual bool IsUserCreated => SafeCall(NativeInstance->IsUserCreated() != 0);

		/// <summary>
		///  Gets a value indicating whether the last function call resulted in an exception. This
		///  attribute exists only in the scope of the current CEF value object.
		/// </summary>
		public virtual bool HasException => SafeCall(NativeInstance->HasException() != 0);

		internal static CefV8Value Create(IntPtr instance)
		{
			return new CefV8Value((cef_v8value_t*) instance);
		}

		/// <summary>
		///  Returns true (1) if this object is pointing to the same handle as |that|
		///  object.
		/// </summary>
		public virtual bool IsSame(CefV8Value that)
		{
			return SafeCall(NativeInstance->IsSame(that != null ? that.GetNativeInstance() : null) != 0);
		}

		/// <summary>
		///  Return a bool value.
		/// </summary>
		public virtual bool GetBoolValue()
		{
			return SafeCall(NativeInstance->GetBoolValue() != 0);
		}

		/// <summary>
		///  Return an int value.
		/// </summary>
		public virtual int GetIntValue()
		{
			return SafeCall(NativeInstance->GetIntValue());
		}

		/// <summary>
		///  Return an unsigned int value.
		/// </summary>
		public virtual uint GetUIntValue()
		{
			return SafeCall(NativeInstance->GetUIntValue());
		}

		/// <summary>
		///  Return a double value.
		/// </summary>
		public virtual double GetDoubleValue()
		{
			return SafeCall(NativeInstance->GetDoubleValue());
		}

		/// <summary>
		///  Return a Date value.
		/// </summary>
		public virtual CefTime GetDateValue()
		{
			return SafeCall(NativeInstance->GetDateValue());
		}

		/// <summary>
		///  Return a string value.
		///  The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public virtual string GetStringValue()
		{
			return SafeCall(CefString.ReadAndFree(NativeInstance->GetStringValue()));
		}

		/// <summary>
		///  Returns the exception resulting from the last function call. This attribute
		///  exists only in the scope of the current CEF value object.
		/// </summary>
		public virtual CefV8Exception GetException()
		{
			return SafeCall(CefV8Exception.Wrap(CefV8Exception.Create, NativeInstance->GetException()));
		}

		/// <summary>
		///  Clears the last exception and returns true (1) on success.
		/// </summary>
		public virtual bool ClearException()
		{
			return SafeCall(NativeInstance->ClearException() != 0);
		}

		/// <summary>
		///  Returns true (1) if this object will re-throw future exceptions. This
		///  attribute exists only in the scope of the current CEF value object.
		/// </summary>
		public virtual bool WillRethrowExceptions()
		{
			return SafeCall(NativeInstance->WillRethrowExceptions() != 0);
		}

		/// <summary>
		///  Set whether this object will re-throw future exceptions. By default
		///  exceptions are not re-thrown. If a exception is re-thrown the current
		///  context should not be accessed again until after the exception has been
		///  caught and not re-thrown. Returns true (1) on success. This attribute
		///  exists only in the scope of the current CEF value object.
		/// </summary>
		public virtual bool SetRethrowExceptions(bool rethrow)
		{
			return SafeCall(NativeInstance->SetRethrowExceptions(rethrow ? 1 : 0) != 0);
		}

		/// <summary>
		///  Returns true (1) if the object has a value with the specified identifier.
		/// </summary>
		public virtual bool HasValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = key != null ? key.Length : 0};
				return SafeCall(NativeInstance->HasValueByKey(&cstr0) != 0);
			}
		}

		/// <summary>
		///  Returns true (1) if the object has a value with the specified identifier.
		/// </summary>
		public virtual bool HasValueByIndex(int index)
		{
			return SafeCall(NativeInstance->HasValueByIndex(index) != 0);
		}

		/// <summary>
		///  Deletes the value with the specified identifier and returns true (1) on
		///  success. Returns false (0) if this function is called incorrectly or an
		///  exception is thrown. For read-only and don&apos;t-delete values this function
		///  will return true (1) even though deletion failed.
		/// </summary>
		public virtual bool DeleteValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = key != null ? key.Length : 0};
				return SafeCall(NativeInstance->DeleteValueByKey(&cstr0) != 0);
			}
		}

		/// <summary>
		///  Deletes the value with the specified identifier and returns true (1) on
		///  success. Returns false (0) if this function is called incorrectly, deletion
		///  fails or an exception is thrown. For read-only and don&apos;t-delete values this
		///  function will return true (1) even though deletion failed.
		/// </summary>
		public virtual bool DeleteValueByIndex(int index)
		{
			return SafeCall(NativeInstance->DeleteValueByIndex(index) != 0);
		}

		/// <summary>
		///  Returns the value with the specified identifier on success. Returns NULL if
		///  this function is called incorrectly or an exception is thrown.
		/// </summary>
		public virtual CefV8Value GetValueByKey(string key)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = key != null ? key.Length : 0};
				return SafeCall(Wrap(Create, NativeInstance->GetValueByKey(&cstr0)));
			}
		}

		/// <summary>
		///  Returns the value with the specified identifier on success. Returns NULL if
		///  this function is called incorrectly or an exception is thrown.
		/// </summary>
		public virtual CefV8Value GetValueByIndex(int index)
		{
			return SafeCall(Wrap(Create, NativeInstance->GetValueByIndex(index)));
		}

		/// <summary>
		///  Associates a value with the specified identifier and returns true (1) on
		///  success. Returns false (0) if this function is called incorrectly or an
		///  exception is thrown. For read-only values this function will return true
		///  (1) even though assignment failed.
		/// </summary>
		public virtual bool SetValueByKey(string key, CefV8Value value, CefV8PropertyAttribute attribute)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = key != null ? key.Length : 0};
				return SafeCall(NativeInstance->SetValueByKey(&cstr0, value != null ? value.GetNativeInstance() : null,
					attribute) != 0);
			}
		}

		/// <summary>
		///  Associates a value with the specified identifier and returns true (1) on
		///  success. Returns false (0) if this function is called incorrectly or an
		///  exception is thrown. For read-only values this function will return true
		///  (1) even though assignment failed.
		/// </summary>
		public virtual bool SetValueByIndex(int index, CefV8Value value)
		{
			return SafeCall(NativeInstance->SetValueByIndex(index, value != null ? value.GetNativeInstance() : null) !=
			                0);
		}

		/// <summary>
		///  Registers an identifier and returns true (1) on success. Access to the
		///  identifier will be forwarded to the cef_v8accessor_t instance passed to
		///  cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this
		///  function is called incorrectly or an exception is thrown. For read-only
		///  values this function will return true (1) even though assignment failed.
		/// </summary>
		public virtual bool SetValueByAccessor(string key, CefV8AccessControl settings,
			CefV8PropertyAttribute attribute)
		{
			fixed (char* s0 = key)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = key != null ? key.Length : 0};
				return SafeCall(NativeInstance->SetValueByAccessor(&cstr0, settings, attribute) != 0);
			}
		}

		/// <summary>
		///  Read the keys for the object&apos;s values into the specified vector. Integer-
		///  based keys will also be returned as strings.
		/// </summary>
		public virtual int GetKeys(CefStringList keys)
		{
			return SafeCall(NativeInstance->GetKeys(keys.GetNativeInstance()));
		}

		/// <summary>
		///  Sets the user data for this object and returns true (1) on success. Returns
		///  false (0) if this function is called incorrectly. This function can only be
		///  called on user created objects.
		/// </summary>
		public virtual bool SetUserData(CefBaseRefCounted userData)
		{
			return SafeCall(NativeInstance->SetUserData(userData.GetNativeInstance()) != 0);
		}

		/// <summary>
		///  Returns the user data, if any, assigned to this object.
		/// </summary>
		public virtual CefBaseRefCounted GetUserData()
		{
			return SafeCall(UnknownRefCounted.Wrap(UnknownRefCounted.Create, NativeInstance->GetUserData()));
		}

		/// <summary>
		///  Returns the amount of externally allocated memory registered for the
		///  object.
		/// </summary>
		public virtual int GetExternallyAllocatedMemory()
		{
			return SafeCall(NativeInstance->GetExternallyAllocatedMemory());
		}

		/// <summary>
		///  Adjusts the amount of registered external memory for the object. Used to
		///  give V8 an indication of the amount of externally allocated memory that is
		///  kept alive by JavaScript objects. V8 uses this information to decide when
		///  to perform global garbage collection. Each cef_v8value_t tracks the amount
		///  of external memory associated with it and automatically decreases the
		///  global total by the appropriate amount on its destruction.
		///  |change_in_bytes| specifies the number of bytes to adjust by. This function
		///  returns the number of bytes associated with the object after the
		///  adjustment. This function can only be called on user created objects.
		/// </summary>
		public virtual int AdjustExternallyAllocatedMemory(int changeInBytes)
		{
			return SafeCall(NativeInstance->AdjustExternallyAllocatedMemory(changeInBytes));
		}

		/// <summary>
		///  Returns the number of elements in the array.
		/// </summary>
		public virtual int GetArrayLength()
		{
			return SafeCall(NativeInstance->GetArrayLength());
		}

		/// <summary>
		///  Returns the ReleaseCallback object associated with the ArrayBuffer or NULL
		///  if the ArrayBuffer was not created with CreateArrayBuffer.
		/// </summary>
		public virtual CefV8ArrayBufferReleaseCallback GetArrayBufferReleaseCallback()
		{
			return SafeCall(CefV8ArrayBufferReleaseCallback.Wrap(CefV8ArrayBufferReleaseCallback.Create,
				NativeInstance->GetArrayBufferReleaseCallback()));
		}

		/// <summary>
		///  Prevent the ArrayBuffer from using it&apos;s memory block by setting the length
		///  to zero. This operation cannot be undone. If the ArrayBuffer was created
		///  with CreateArrayBuffer then
		///  cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to
		///  release the underlying buffer.
		/// </summary>
		public virtual int NeuterArrayBuffer()
		{
			return SafeCall(NativeInstance->NeuterArrayBuffer());
		}

		/// <summary>
		///  Returns the function name.
		///  The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public virtual string GetFunctionName()
		{
			return SafeCall(CefString.ReadAndFree(NativeInstance->GetFunctionName()));
		}

		/// <summary>
		///  Returns the function handler or NULL if not a CEF-created function.
		/// </summary>
		public virtual CefV8Handler GetFunctionHandler()
		{
			return SafeCall(CefV8Handler.Wrap(CefV8Handler.Create, NativeInstance->GetFunctionHandler()));
		}

		/// <summary>
		///  Execute the function using the current V8 context. This function should
		///  only be called from within the scope of a cef_v8handler_t or
		///  cef_v8accessor_t callback, or in combination with calling enter() and
		///  exit() on a stored cef_v8context_t reference. |object| is the receiver
		///  (&apos;this&apos; object) of the function. If |object| is NULL the current context&apos;s
		///  global object will be used. |arguments| is the list of arguments that will
		///  be passed to the function. Returns the function return value on success.
		///  Returns NULL if this function is called incorrectly or an exception is
		///  thrown.
		/// </summary>
		public virtual CefV8Value ExecuteFunction(CefV8Value @object, CefV8Value[] arguments)
		{
			var arr2 = (cef_v8value_t**) Marshal.AllocHGlobal(sizeof(cef_v8value_t*) * arguments.Length);
			for (var i = 0; i < arguments.Length; i++)
			{
				var e2 = arguments[i];
				*(arr2 + i) = e2 != null ? e2.GetNativeInstance() : null;
			}

			var rv = Wrap(Create,
				NativeInstance->ExecuteFunction(@object != null ? @object.GetNativeInstance() : null,
					new UIntPtr((uint) arguments.Length), arr2));
			Marshal.FreeHGlobal((IntPtr) arr2);
			GC.KeepAlive(this);
			return rv;
		}

		/// <summary>
		///  Execute the function using the specified V8 context. |object| is the
		///  receiver (&apos;this&apos; object) of the function. If |object| is NULL the specified
		///  context&apos;s global object will be used. |arguments| is the list of arguments
		///  that will be passed to the function. Returns the function return value on
		///  success. Returns NULL if this function is called incorrectly or an
		///  exception is thrown.
		/// </summary>
		public virtual CefV8Value ExecuteFunctionWithContext(CefV8Context context, CefV8Value @object,
			CefV8Value[] arguments)
		{
			var arr3 = (cef_v8value_t**) Marshal.AllocHGlobal(sizeof(cef_v8value_t*) * arguments.Length);
			for (var i = 0; i < arguments.Length; i++)
			{
				var e3 = arguments[i];
				*(arr3 + i) = e3 != null ? e3.GetNativeInstance() : null;
			}

			var rv = Wrap(Create,
				NativeInstance->ExecuteFunctionWithContext(context != null ? context.GetNativeInstance() : null,
					@object != null ? @object.GetNativeInstance() : null, new UIntPtr((uint) arguments.Length), arr3));
			Marshal.FreeHGlobal((IntPtr) arr3);
			GC.KeepAlive(this);
			return rv;
		}
	}
}