// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_command_line_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using CefNet.CApi;

namespace CefNet
{
	/// <summary>
	///  Structure used to create and/or parse command line arguments. Arguments with
	///  &apos;--&apos;, &apos;-&apos; and, on Windows, &apos;/&apos; prefixes are considered switches. Switches
	///  will always precede any arguments without switch prefixes. Switches can
	///  optionally have a value specified using the &apos;=&apos; delimiter (e.g.
	///  &quot;-switch=value&quot;). An argument of &quot;--&quot; will terminate switch parsing with all
	///  subsequent tokens, regardless of prefix, being interpreted as non-switch
	///  arguments. Switch names are considered case-insensitive. This structure can
	///  be used before cef_initialize() is called.
	/// </summary>
	/// <remarks>
	///  Role: Proxy
	/// </remarks>
	public unsafe partial class CefCommandLine : CefBaseRefCounted<cef_command_line_t>
	{
		public CefCommandLine(cef_command_line_t* instance)
			: base((cef_base_ref_counted_t*) instance)
		{
		}

		/// <summary>
		///  Gets a value indicating whether this object is valid. Do not call any other functions
		///  if this property returns false.
		/// </summary>
		public virtual bool IsValid => SafeCall(NativeInstance->IsValid() != 0);

		/// <summary>
		///  Gets a value indicating whether the values of this object are read-only. Some APIs may
		///  expose read-only objects.
		/// </summary>
		public virtual bool IsReadOnly => SafeCall(NativeInstance->IsReadOnly() != 0);

		/// <summary>
		///  Constructs and returns the represented command line string. Use this
		///  function cautiously because quoting behavior is unclear.
		///  The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public virtual string CommandLineString =>
			SafeCall(CefString.ReadAndFree(NativeInstance->GetCommandLineString()));

		/// <summary>
		///  Gets and sets the program part of the command line string (the first item).
		///  The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public virtual string Program
		{
			get => SafeCall(CefString.ReadAndFree(NativeInstance->GetProgram()));
			set
			{
				fixed (char* s0 = value)
				{
					var cstr0 = new cef_string_t {Str = s0, Length = value != null ? value.Length : 0};
					NativeInstance->SetProgram(&cstr0);
				}

				GC.KeepAlive(this);
			}
		}

		/// <summary>
		///  Gets a value indicating whether the command line has switches.
		/// </summary>
		public virtual bool HasSwitches => SafeCall(NativeInstance->HasSwitches() != 0);

		/// <summary>
		///  Gets a value indicating whether there are remaining command line arguments.
		/// </summary>
		public virtual bool HasArguments => SafeCall(NativeInstance->HasArguments() != 0);

		internal static CefCommandLine Create(IntPtr instance)
		{
			return new CefCommandLine((cef_command_line_t*) instance);
		}

		/// <summary>
		///  Returns a writable copy of this object.
		/// </summary>
		public virtual CefCommandLine Copy()
		{
			return SafeCall(Wrap(Create, NativeInstance->Copy()));
		}

		/// <summary>
		///  Initialize the command line with the specified |argc| and |argv| values.
		///  The first argument must be the name of the program. This function is only
		///  supported on non-Windows platforms.
		/// </summary>
		public virtual void InitFromArgv(int argc, IntPtr argv)
		{
			NativeInstance->InitFromArgv(argc, (byte**) argv);
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Initialize the command line with the string returned by calling
		///  GetCommandLineW(). This function is only supported on Windows.
		/// </summary>
		public virtual void InitFromString(string commandLine)
		{
			fixed (char* s0 = commandLine)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = commandLine != null ? commandLine.Length : 0};
				NativeInstance->InitFromString(&cstr0);
			}

			GC.KeepAlive(this);
		}

		/// <summary>
		///  Reset the command-line switches and arguments but leave the program
		///  component unchanged.
		/// </summary>
		public virtual void Reset()
		{
			NativeInstance->Reset();
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Retrieve the original command line string as a vector of strings. The argv
		///  array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }
		/// </summary>
		public virtual void GetArgv(CefStringList argv)
		{
			NativeInstance->GetArgv(argv.GetNativeInstance());
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Returns true (1) if the command line contains the given switch.
		/// </summary>
		public virtual bool HasSwitch(string name)
		{
			fixed (char* s0 = name)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = name != null ? name.Length : 0};
				return SafeCall(NativeInstance->HasSwitch(&cstr0) != 0);
			}
		}

		/// <summary>
		///  Returns the value associated with the given switch. If the switch has no
		///  value or isn&apos;t present this function returns the NULL string.
		///  The resulting string must be freed by calling cef_string_userfree_free().
		/// </summary>
		public virtual string GetSwitchValue(string name)
		{
			fixed (char* s0 = name)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = name != null ? name.Length : 0};
				return SafeCall(CefString.ReadAndFree(NativeInstance->GetSwitchValue(&cstr0)));
			}
		}

		/// <summary>
		///  Returns the map of switch names and values. If a switch has no value an
		///  NULL string is returned.
		/// </summary>
		public virtual void GetSwitches(CefStringMap switches)
		{
			NativeInstance->GetSwitches(switches);
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Add a switch to the end of the command line. If the switch has no value
		///  pass an NULL value string.
		/// </summary>
		public virtual void AppendSwitch(string name)
		{
			fixed (char* s0 = name)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = name != null ? name.Length : 0};
				NativeInstance->AppendSwitch(&cstr0);
			}

			GC.KeepAlive(this);
		}

		/// <summary>
		///  Add a switch with the specified value to the end of the command line.
		/// </summary>
		public virtual void AppendSwitchWithValue(string name, string value)
		{
			fixed (char* s0 = name)
			fixed (char* s1 = value)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = name != null ? name.Length : 0};
				var cstr1 = new cef_string_t {Str = s1, Length = value != null ? value.Length : 0};
				NativeInstance->AppendSwitchWithValue(&cstr0, &cstr1);
			}

			GC.KeepAlive(this);
		}

		/// <summary>
		///  Get the remaining command line arguments.
		/// </summary>
		public virtual void GetArguments(CefStringList arguments)
		{
			NativeInstance->GetArguments(arguments.GetNativeInstance());
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Add an argument to the end of the command line.
		/// </summary>
		public virtual void AppendArgument(string argument)
		{
			fixed (char* s0 = argument)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = argument != null ? argument.Length : 0};
				NativeInstance->AppendArgument(&cstr0);
			}

			GC.KeepAlive(this);
		}

		/// <summary>
		///  Insert a command before the current command. Common for debuggers, like
		///  &quot;valgrind&quot; or &quot;gdb --args&quot;.
		/// </summary>
		public virtual void PrependWrapper(string wrapper)
		{
			fixed (char* s0 = wrapper)
			{
				var cstr0 = new cef_string_t {Str = s0, Length = wrapper != null ? wrapper.Length : 0};
				NativeInstance->PrependWrapper(&cstr0);
			}

			GC.KeepAlive(this);
		}
	}
}