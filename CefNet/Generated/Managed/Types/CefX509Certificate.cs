// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_x509certificate_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.InteropServices;
using CefNet.CApi;

namespace CefNet
{
	/// <summary>
	///  Structure representing a X.509 certificate.
	/// </summary>
	/// <remarks>
	///  Role: Proxy
	/// </remarks>
	public unsafe class CefX509Certificate : CefBaseRefCounted<cef_x509certificate_t>
	{
		public CefX509Certificate(cef_x509certificate_t* instance)
			: base((cef_base_ref_counted_t*) instance)
		{
		}

		/// <summary>
		///  Gets the subject of the X.509 certificate. For HTTPS server certificates
		///  this represents the web server.  The common name of the subject should
		///  match the host name of the web server.
		/// </summary>
		public virtual CefX509CertPrincipal Subject =>
			SafeCall(CefX509CertPrincipal.Wrap(CefX509CertPrincipal.Create, NativeInstance->GetSubject()));

		/// <summary>
		///  Gets the issuer of the X.509 certificate.
		/// </summary>
		public virtual CefX509CertPrincipal Issuer =>
			SafeCall(CefX509CertPrincipal.Wrap(CefX509CertPrincipal.Create, NativeInstance->GetIssuer()));

		/// <summary>
		///  Gets the DER encoded serial number for the X.509 certificate. The value
		///  possibly includes a leading 00 byte.
		/// </summary>
		public virtual CefBinaryValue SerialNumber =>
			SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetSerialNumber()));

		/// <summary>
		///  Gets the date before which the X.509 certificate is invalid.
		///  CefTime.GetTimeT() will return 0 if no date was specified.
		/// </summary>
		public virtual CefTime ValidStart => SafeCall(NativeInstance->GetValidStart());

		/// <summary>
		///  Gets the date after which the X.509 certificate is invalid.
		///  CefTime.GetTimeT() will return 0 if no date was specified.
		/// </summary>
		public virtual CefTime ValidExpiry => SafeCall(NativeInstance->GetValidExpiry());

		/// <summary>
		///  Gets the DER encoded data for the X.509 certificate.
		/// </summary>
		public virtual CefBinaryValue DEREncoded =>
			SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetDEREncoded()));

		/// <summary>
		///  Gets the PEM encoded data for the X.509 certificate.
		/// </summary>
		public virtual CefBinaryValue PEMEncoded =>
			SafeCall(CefBinaryValue.Wrap(CefBinaryValue.Create, NativeInstance->GetPEMEncoded()));

		/// <summary>
		///  Gets the number of certificates in the issuer chain. If 0, the
		///  certificate is self-signed.
		/// </summary>
		public virtual long IssuerChainSize => SafeCall((long) NativeInstance->GetIssuerChainSize());

		internal static CefX509Certificate Create(IntPtr instance)
		{
			return new CefX509Certificate((cef_x509certificate_t*) instance);
		}

		/// <summary>
		///  Returns the DER encoded data for the certificate issuer chain. If we failed
		///  to encode a certificate in the chain it is still present in the array but
		///  is an NULL string.
		/// </summary>
		public virtual void GetDEREncodedIssuerChain(ref long chainCount, ref CefBinaryValue[] chain)
		{
			var c1 = new UIntPtr((uint) chain.Length);
			var arr1 = (cef_binary_value_t**) Marshal.AllocHGlobal(sizeof(cef_binary_value_t*) * chain.Length);
			for (var i = 0; i < chain.Length; i++)
			{
				var e1 = chain[i];
				*(arr1 + i) = e1 != null ? e1.GetNativeInstance() : null;
			}

			NativeInstance->GetDEREncodedIssuerChain(&c1, arr1);
			chainCount = (long) c1;
			for (var i = (int) c1; i >= 0; i--) chain[i] = CefBinaryValue.Wrap(CefBinaryValue.Create, *(arr1 + i));
			Marshal.FreeHGlobal((IntPtr) arr1);
			GC.KeepAlive(this);
		}

		/// <summary>
		///  Returns the PEM encoded data for the certificate issuer chain. If we failed
		///  to encode a certificate in the chain it is still present in the array but
		///  is an NULL string.
		/// </summary>
		public virtual void GetPEMEncodedIssuerChain(ref long chainCount, ref CefBinaryValue[] chain)
		{
			var c1 = new UIntPtr((uint) chain.Length);
			var arr1 = (cef_binary_value_t**) Marshal.AllocHGlobal(sizeof(cef_binary_value_t*) * chain.Length);
			for (var i = 0; i < chain.Length; i++)
			{
				var e1 = chain[i];
				*(arr1 + i) = e1 != null ? e1.GetNativeInstance() : null;
			}

			NativeInstance->GetPEMEncodedIssuerChain(&c1, arr1);
			chainCount = (long) c1;
			for (var i = (int) c1; i >= 0; i--) chain[i] = CefBinaryValue.Wrap(CefBinaryValue.Create, *(arr1 + i));
			Marshal.FreeHGlobal((IntPtr) arr1);
			GC.KeepAlive(this);
		}
	}
}