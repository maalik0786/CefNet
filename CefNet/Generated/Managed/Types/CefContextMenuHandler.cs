// --------------------------------------------------------------------------------------------
// Copyright (c) 2019 The CefNet Authors. All rights reserved.
// Licensed under the MIT license.
// See the licence file in the project root for full license information.
// --------------------------------------------------------------------------------------------
// Generated by CefGen
// Source: Generated/Native/Types/cef_context_menu_handler_t.cs
// --------------------------------------------------------------------------------------------﻿
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
// --------------------------------------------------------------------------------------------

#pragma warning disable 0169, 1591, 1573

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CefNet.CApi;
using CefNet.Internal;

namespace CefNet
{
	/// <summary>
	///  Implement this structure to handle context menu events. The functions of this
	///  structure will be called on the UI thread.
	/// </summary>
	/// <remarks>
	///  Role: Handler
	/// </remarks>
	public unsafe class CefContextMenuHandler : CefBaseRefCounted<cef_context_menu_handler_t>,
		ICefContextMenuHandlerPrivate
	{
		private static readonly OnBeforeContextMenuDelegate fnOnBeforeContextMenu = OnBeforeContextMenuImpl;

		private static readonly RunContextMenuDelegate fnRunContextMenu = RunContextMenuImpl;

		private static readonly OnContextMenuCommandDelegate fnOnContextMenuCommand = OnContextMenuCommandImpl;

		private static readonly OnContextMenuDismissedDelegate fnOnContextMenuDismissed = OnContextMenuDismissedImpl;

		public CefContextMenuHandler()
		{
			var self = NativeInstance;
			self->on_before_context_menu = (void*) Marshal.GetFunctionPointerForDelegate(fnOnBeforeContextMenu);
			self->run_context_menu = (void*) Marshal.GetFunctionPointerForDelegate(fnRunContextMenu);
			self->on_context_menu_command = (void*) Marshal.GetFunctionPointerForDelegate(fnOnContextMenuCommand);
			self->on_context_menu_dismissed = (void*) Marshal.GetFunctionPointerForDelegate(fnOnContextMenuDismissed);
		}

		public CefContextMenuHandler(cef_context_menu_handler_t* instance)
			: base((cef_base_ref_counted_t*) instance)
		{
		}

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefContextMenuHandlerPrivate.AvoidOnBeforeContextMenu();

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefContextMenuHandlerPrivate.AvoidRunContextMenu();

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefContextMenuHandlerPrivate.AvoidOnContextMenuCommand();

		[MethodImpl(MethodImplOptions.ForwardRef)]
		extern bool ICefContextMenuHandlerPrivate.AvoidOnContextMenuDismissed();

		internal static CefContextMenuHandler Create(IntPtr instance)
		{
			return new CefContextMenuHandler((cef_context_menu_handler_t*) instance);
		}

		/// <summary>
		///  Called before a context menu is displayed. |params| provides information
		///  about the context menu state. |model| initially contains the default
		///  context menu. The |model| can be cleared to show no context menu or
		///  modified to show a custom menu. Do not keep references to |params| or
		///  |model| outside of this callback.
		/// </summary>
		protected internal virtual void OnBeforeContextMenu(CefBrowser browser, CefFrame frame,
			CefContextMenuParams @params, CefMenuModel model)
		{
		}

		// void (*)(_cef_context_menu_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, _cef_context_menu_params_t* params, _cef_menu_model_t* model)*
		private static void OnBeforeContextMenuImpl(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, cef_menu_model_t* model)
		{
			var instance = GetInstance((IntPtr) self) as CefContextMenuHandler;
			if (instance == null || ((ICefContextMenuHandlerPrivate) instance).AvoidOnBeforeContextMenu())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*) browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*) frame);
				ReleaseIfNonNull((cef_base_ref_counted_t*) @params);
				ReleaseIfNonNull((cef_base_ref_counted_t*) model);
				return;
			}

			instance.OnBeforeContextMenu(CefBrowser.Wrap(CefBrowser.Create, browser),
				CefFrame.Wrap(CefFrame.Create, frame), CefContextMenuParams.Wrap(CefContextMenuParams.Create, @params),
				CefMenuModel.Wrap(CefMenuModel.Create, model));
		}

		/// <summary>
		///  Called to allow custom display of the context menu. |params| provides
		///  information about the context menu state. |model| contains the context menu
		///  model resulting from OnBeforeContextMenu. For custom display return true
		///  (1) and execute |callback| either synchronously or asynchronously with the
		///  selected command ID. For default display return false (0). Do not keep
		///  references to |params| or |model| outside of this callback.
		/// </summary>
		protected internal virtual bool RunContextMenu(CefBrowser browser, CefFrame frame, CefContextMenuParams @params,
			CefMenuModel model, CefRunContextMenuCallback callback)
		{
			return default;
		}

		// int (*)(_cef_context_menu_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, _cef_context_menu_params_t* params, _cef_menu_model_t* model, _cef_run_context_menu_callback_t* callback)*
		private static int RunContextMenuImpl(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, cef_menu_model_t* model,
			cef_run_context_menu_callback_t* callback)
		{
			var instance = GetInstance((IntPtr) self) as CefContextMenuHandler;
			if (instance == null || ((ICefContextMenuHandlerPrivate) instance).AvoidRunContextMenu())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*) browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*) frame);
				ReleaseIfNonNull((cef_base_ref_counted_t*) @params);
				ReleaseIfNonNull((cef_base_ref_counted_t*) model);
				ReleaseIfNonNull((cef_base_ref_counted_t*) callback);
				return default;
			}

			return instance.RunContextMenu(CefBrowser.Wrap(CefBrowser.Create, browser),
				CefFrame.Wrap(CefFrame.Create, frame), CefContextMenuParams.Wrap(CefContextMenuParams.Create, @params),
				CefMenuModel.Wrap(CefMenuModel.Create, model),
				CefRunContextMenuCallback.Wrap(CefRunContextMenuCallback.Create, callback))
				? 1
				: 0;
		}

		/// <summary>
		///  Called to execute a command selected from the context menu. Return true (1)
		///  if the command was handled or false (0) for the default implementation. See
		///  cef_menu_id_t for the command ids that have default implementations. All
		///  user-defined command ids should be between MENU_ID_USER_FIRST and
		///  MENU_ID_USER_LAST. |params| will have the same values as what was passed to
		///  on_before_context_menu(). Do not keep a reference to |params| outside of
		///  this callback.
		/// </summary>
		protected internal virtual bool OnContextMenuCommand(CefBrowser browser, CefFrame frame,
			CefContextMenuParams @params, int commandId, CefEventFlags eventFlags)
		{
			return default;
		}

		// int (*)(_cef_context_menu_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame, _cef_context_menu_params_t* params, int command_id, cef_event_flags_t event_flags)*
		private static int OnContextMenuCommandImpl(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, int command_id, CefEventFlags event_flags)
		{
			var instance = GetInstance((IntPtr) self) as CefContextMenuHandler;
			if (instance == null || ((ICefContextMenuHandlerPrivate) instance).AvoidOnContextMenuCommand())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*) browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*) frame);
				ReleaseIfNonNull((cef_base_ref_counted_t*) @params);
				return default;
			}

			return instance.OnContextMenuCommand(CefBrowser.Wrap(CefBrowser.Create, browser),
				CefFrame.Wrap(CefFrame.Create, frame), CefContextMenuParams.Wrap(CefContextMenuParams.Create, @params),
				command_id, event_flags)
				? 1
				: 0;
		}

		/// <summary>
		///  Called when the context menu is dismissed irregardless of whether the menu
		///  was NULL or a command was selected.
		/// </summary>
		protected internal virtual void OnContextMenuDismissed(CefBrowser browser, CefFrame frame)
		{
		}

		// void (*)(_cef_context_menu_handler_t* self, _cef_browser_t* browser, _cef_frame_t* frame)*
		private static void OnContextMenuDismissedImpl(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame)
		{
			var instance = GetInstance((IntPtr) self) as CefContextMenuHandler;
			if (instance == null || ((ICefContextMenuHandlerPrivate) instance).AvoidOnContextMenuDismissed())
			{
				ReleaseIfNonNull((cef_base_ref_counted_t*) browser);
				ReleaseIfNonNull((cef_base_ref_counted_t*) frame);
				return;
			}

			instance.OnContextMenuDismissed(CefBrowser.Wrap(CefBrowser.Create, browser),
				CefFrame.Wrap(CefFrame.Create, frame));
		}

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate void OnBeforeContextMenuDelegate(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, cef_menu_model_t* model);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate int RunContextMenuDelegate(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, cef_menu_model_t* model,
			cef_run_context_menu_callback_t* callback);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate int OnContextMenuCommandDelegate(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame, cef_context_menu_params_t* @params, int command_id, CefEventFlags event_flags);

		[UnmanagedFunctionPointer(CallingConvention.Winapi)]
		private delegate void OnContextMenuDismissedDelegate(cef_context_menu_handler_t* self, cef_browser_t* browser,
			cef_frame_t* frame);
	}
}